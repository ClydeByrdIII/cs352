class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
class BinarySearch{
    public static void main(String[] a){
	System.out.println(new BS().Start(20));
    }
}
// This class contains an array of integers and
// methods to initialize, print and search the array
// using Binary Search

class BS{
    int[] number ;
    int size ;

    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;
	aux01 = this.Init(sz);
	aux02 = this.Print();
	if (this.Search(8)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(19)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(20)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(21)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(37)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(38)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(39)) System.out.println(1) ;
	else System.out.println(0) ;
	if (this.Search(50)) System.out.println(1) ;
	else System.out.println(0) ;

	return 999 ;
    }


    // Search for a specific value (num) using
    // binary search
    public boolean Search(int num){
	boolean bs01 ;
	int right ;
	int left ;
	boolean var_cont ;
	int medium ;
	int aux01 ;
	int nt ;

	aux01 = 0 ;
	bs01 = false ;
	right = number.length ;
	right = right - 1 ;
	left = 0 ;
	var_cont = true ;
	while (var_cont){
	    medium = left + right ;
	    medium = this.Div(medium);
	    aux01 = number[medium] ;
	    if (num < aux01) right = medium - 1 ;
	    else left = medium + 1 ;
	    if (this.Compare(aux01,num)) var_cont = false ;
	    else var_cont = true ;
	    if (right < left) var_cont = false ;
	    else nt = 0 ;
	}

	if (this.Compare(aux01,num)) bs01 = true ;
	else bs01 = false ;
	return bs01 ;
    }

    // This method computes and returns the
    // integer division of a number (num) by 2
    public int Div(int num){
	int count01 ;
	int count02 ;
	int aux03 ;

	count01 = 0 ;
	count02 = 0 ;
	aux03 = num - 1 ;
	while (count02 < aux03) {
	    count01 = count01 + 1 ;
	    count02 = count02 + 2 ;
	}
	return count01 ;	
    }

    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;

	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

    // Print the integer array
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	System.out.println(99999);
	return 0 ;
    }
    

    // Initialize the integer array
    public int Init(int sz){
	int j ;
	int k ;
	int aux02 ;
	int aux01 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class BinaryTree{
    public static void main(String[] a){
	System.out.println(new BT().Start());
    }
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Print();
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}

class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;

    // Initialize a node with a key value and no children
    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    // Update the right child with rn
    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }
    
    // Update the left child with ln
    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }
    
    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }


    // Insert a new element in the tree
    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	boolean cont ;
	int key_aux ;
	Tree current_node ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }


    // Delete an element from the tree
    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean is_root ;
	int key_aux ;
	boolean ntb ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if ((!current_node.GetHas_Right()) && 
			    (!current_node.GetHas_Left()) )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }


    // Check if the element to be removed will use the
    // righ or left subtree if one exists
    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		//auxtree01 = p_node.GetLeft() ;
		//auxkey2 = auxtree01.GetKey() ;
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // right subtree
    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Right()){
	    //auxtree01 = c_node.GetRight() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }


    // Copy the child key to the parent until a leaf is
    // found and remove the leaf. This is done with the
    // left subtree
    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;

	while (c_node.GetHas_Left()){
	    //auxtree01 = c_node.GetLeft() ;
	    //auxint02 = auxtree01.GetKey();
	    //ntb = c_node.SetKey(auxint02);
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }

    // Search for an elemnt in the tree
    public int Search(int v_key){
	boolean cont ;
	int ifound ;
	Tree current_node;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    // Invoke the method to really print the tree elements
    public boolean Print(){
	Tree current_node;
	boolean ntb ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    // Print the elements of the tree
    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    //auxtree01 = node.GetLeft() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    //auxtree01 = node.GetRight() ;
	    //ntb = this.RecPrint(auxtree01);
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }

}
   
class BubbleSort{
    public static void main(String[] a){
	System.out.println(new BBS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Bublesort
class BBS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Bublesort method
    public int Sort(){
	int nt ;
	int i ;
	int aux02 ;
	int aux04 ;
	int aux05 ;
	int aux06 ;
	int aux07 ;
	int j ;
	int t ;
	i = size - 1 ;
	aux02 = 0 - 1 ;
	while (aux02 < i) {
	    j = 1 ;
	    //aux03 = i+1 ;
	    while (j < (i+1)){
		aux07 = j - 1 ;
		aux04 = number[aux07] ;
		aux05 = number[j] ;
		if (aux05 < aux04) {
		    aux06 = j - 1 ;
		    t = number[aux06] ;
		    number[aux06] = number[j] ;
		    number[j] = t;
		}
		else nt = 0 ;
		j = j + 1 ;
	    }
	    i = i - 1 ;
	}
	return 0 ;
    }

    // Printing method
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    
    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Factorial{
    public static void main(String[] a){
	System.out.println(new Fac().ComputeFac(10));
    }
}

class Fac {

    public int ComputeFac(int num){
	int num_aux ;
	if (num < 1)
	    num_aux = 1 ;
	else 
	    num_aux = num * (this.ComputeFac(num-1)) ;
	return num_aux ;
    }

}
class LinearSearch{
    public static void main(String[] a){
	System.out.println(new LS().Start(10));
    }
}


// This class contains an array of integers and
// methods to initialize, print and search the array
// using Linear Search
class LS {
    int[] number ;
    int size ;
    
    // Invoke methods to initialize, print and search
    // for elements on the array
    public int Start(int sz){
	int aux01 ;
	int aux02 ;

	aux01 = this.Init(sz);
	aux02 = this.Print();
	System.out.println(9999);
	System.out.println(this.Search(8));
	System.out.println(this.Search(12)) ;
	System.out.println(this.Search(17)) ;
	System.out.println(this.Search(50)) ;
	return 55 ;
    }

    // Print array of integers
    public int Print(){
	int j ;

	j = 1 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }

    // Search for a specific value (num) using
    // linear search
    public int Search(int num){
	int j ;
	boolean ls01 ;
	int ifound ;
	int aux01 ;
	int aux02 ;
	int nt ;

	j = 1 ;
	ls01 = false ;
	ifound = 0 ;
	
	//System.out.println(num);
	while (j < (size)) {
	    aux01 = number[j] ;
	    aux02 = num + 1 ;
	    if (aux01 < num) nt = 0 ;
	    else if (!(aux01 < aux02)) nt = 0 ;
	    else {
		ls01 = true ;
		ifound = 1 ;
		j = size ;
	    }
	    j = j + 1 ;
	}

	return ifound ;
    }


    
    // initialize array of integers with some
    // some sequence
    public int Init(int sz){
	int j ;
	int k ;
	int aux01 ;
	int aux02 ;

	size = sz ;
	number = new int[sz] ;
	
	j = 1 ;
	k = size + 1 ;
	while (j < (size)) {
	    aux01 = 2 * j ;
	    aux02 = k - 3 ;
	    number[j] = aux01 + aux02 ;
	    j = j + 1 ;
	    k = k - 1 ;
	}
	return 0 ;	
    }

}
class LinkedList{
    public static void main(String[] a){
	System.out.println(new LL().Start());
    }
}

class Element {
    int Age ;          
    int Salary ;
    boolean Married ;

    // Initialize some class variables
    public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
    }

    public int GetAge(){
	return Age ;
    }
    
    public int GetSalary(){
	return Salary ;
    }

    public boolean GetMarried(){
	return Married ;
    }

    // This method returns true if the object "other"
    // has the same values for age, salary and 
    public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
    }

    // This method compares two integers and
    // returns true if they are equal and false
    // otherwise
    public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
    }

}

class List{
    Element elem ;
    List next ;
    boolean end ;

    // Initialize the node list as the last node
    public boolean Init(){
	end = true ;
	return true ;
    }

    // Initialize the values of a new node
    public boolean InitNew(Element v_elem, List v_next, boolean v_end){
	end = v_end ;
	elem = v_elem ;
	next = v_next ;
	return true ;
    }
    
    // Insert a new node at the beginning of the list
    public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
    }
    
    
    // Update the the pointer to the next node
    public boolean SetNext(List v_next){
	next = v_next ;
	return true ;
    }
    
    // Delete an element e from the list
    public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
    }
    
    
    // Search for an element e on the list
    public int Search(Element e){
	int int_ret_val ;
	List aux01 ;
	Element var_elem ;
	boolean var_end ;
	int nt ;

	int_ret_val = 0 ;
	aux01 = this ;
	var_end = end;
	var_elem = elem ;
	while (!var_end){
	    if (e.Equal(var_elem)){
		int_ret_val = 1 ;
	    }
	    else nt = 0 ;
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}
	return int_ret_val ;
    }
    
    public boolean GetEnd(){
	return end ;
    }
    
    public Element GetElem(){
	return elem ;
    }
    
    public List GetNext(){
	return next ;
    }
    
    
    // Print the linked list
    public boolean Print(){
	List aux01 ;
	boolean var_end ;
	Element  var_elem ;

	aux01 = this ;
	var_end = end ;
	var_elem = elem ;
	while (!var_end){
	    System.out.println(var_elem.GetAge());
	    aux01 = aux01.GetNext() ;
	    var_end = aux01.GetEnd();
	    var_elem = aux01.GetElem();
	}

	return true ;
    }
}
    

// this class invokes the methods to insert, delete,
// search and print the linked list
class LL{

    public int Start(){

	List head ;
	List last_elem ;
	boolean aux01 ;
	Element el01 ;
	Element el02 ;
	Element el03 ;

	last_elem = new List();
	aux01 = last_elem.Init();
	head = last_elem ;
	aux01 = head.Init();
	aux01 = head.Print();

	// inserting first element
	el01 = new Element();
	aux01 = el01.Init(25,37000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting second  element
	el01 = new Element();
	aux01 = el01.Init(39,42000,true);
	el02 = el01 ;
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(10000000);
	// inserting third element
	el01 = new Element();
	aux01 = el01.Init(22,34000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	el03 = new Element();
	aux01 = el03.Init(27,34000,false);
	System.out.println(head.Search(el02));
	System.out.println(head.Search(el03));
	System.out.println(10000000);
	// inserting fourth element
	el01 = new Element();
	aux01 = el01.Init(28,35000,false);
	head = head.Insert(el01);
	aux01 = head.Print();
	System.out.println(2220000);

	head = head.Delete(el02);
	aux01 = head.Print();
	System.out.println(33300000);


	head = head.Delete(el01);
	aux01 = head.Print();
	System.out.println(44440000);
	
	return 0 ;
	
	
    }
    
}
class QuickSort{
    public static void main(String[] a){
	System.out.println(new QS().Start(10));
    }
}


// This class contains the array of integers and
// methods to initialize, print and sort the array
// using Quicksort
class QS{
    
    int[] number ;
    int size ;

    // Invoke the Initialization, Sort and Printing
    // Methods
    public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(9999);
	aux01 = size - 1 ;
	aux01 = this.Sort(0,aux01);
	aux01 = this.Print();
	return 0 ;
    }

 
    // Sort array of integers using Quicksort method
    public int Sort(int left, int right){
	int v ;
	int i ;
	int j ;
	int nt;
	int t ;
	boolean cont01;
	boolean cont02;
	int aux03 ;
	t = 0 ;
	if (left < right){
	    v = number[right] ;
	    i = left - 1 ;
	    j = right ;
	    cont01 = true ;
	    while (cont01){
		cont02 = true ;
		while (cont02){
		    i = i + 1 ;
		    aux03 = number[i] ;
		    if (!(aux03<v)) cont02 = false ;
		    else cont02 = true ;
		}
		cont02 = true ;
		while (cont02){
		    j = j - 1 ;
		    aux03 = number[j] ;
		    if (!(v < aux03)) cont02 = false ;
		    else cont02 = true ;
		}


		t = number[i] ;
		number[i] = number[j] ;
		number[j] = t ;
		//aux03 = i + 1 ;
		if ( j < (i+1)) cont01 = false ;
		else cont01 = true ;
	    }
	    number[j] = number[i] ;
	    number[i] = number[right] ;
	    number[right] = t ;
	    nt = this.Sort(left,i-1);
	    nt = this.Sort(i+1,right);
	}
	else nt = 0 ;
	return 0 ;
    }

    
    // Print array of integers
    public int Print(){
	int j ;
	j = 0 ;
	while (j < (size)) {
	    System.out.println(number[j]);
	    j = j + 1 ;
	}
	return 0 ;
    }
    

    // Initialize array of integers
    public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return 0 ;	
    }

}
class Spill {
    public static void main(String[] a) {
        new Spiller().spill();
    }
}

class Spiller {
    public int spill() {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
        int j;
        int k;
        int l;
        int m;
        int n;
        int o;
        int p;
        int q;
        int r;
        int s;
        int t;
        int u;
        int v;
        int w;
        int x;
        int y;
        int z;

        a = 1;
        b = 2;
        c = 3;
        d = 4;
        e = 5;
        f = 6;
        g = 7;
        h = 8;
        i = 9;
        j = 10;
        k = 11;
        l = 12;
        m = 13;
        n = 14;
        o = 15;
        p = 16;
        q = 17;
        r = 18;
        s = 19;
        t = 20;
        u = 21;
        v = 22;
        w = 23;
        x = 24;
        y = 25;
        z = 26;

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
        System.out.println(j);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);
        System.out.println(n);
        System.out.println(o);
        System.out.println(p);
        System.out.println(q);
        System.out.println(r);
        System.out.println(s);
        System.out.println(t);
        System.out.println(u);
        System.out.println(v);
        System.out.println(w);
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);

        return 0;
    }
}
class StackArgs {
    public static void main(String[] a) {
        System.out.println(new SA().go(1, 1, 2, 3, 5, 8, 13, 21, 34));
    }
}

class SA {
    public int go(int a, int b, int c, int d, int e, int f, int g, int h, int i) {
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);

        return 0;
    }
}
// The classes are basically the same as the BinaryTree 
// file except the visitor classes and the accept method
// in the Tree class

class TreeVisitor{
    public static void main(String[] a){
	System.out.println(new TV().Start());
    }
}

class TV {

    public int Start(){
	Tree root ;
	boolean ntb ;
	int nti ;
	MyVisitor v ;

	root = new Tree();
	ntb = root.Init(16);
	ntb = root.Print();
	System.out.println(100000000);
	ntb = root.Insert(8) ;
	ntb = root.Insert(24) ;
	ntb = root.Insert(4) ;
	ntb = root.Insert(12) ;
	ntb = root.Insert(20) ;
	ntb = root.Insert(28) ;
	ntb = root.Insert(14) ;
	ntb = root.Print();
	System.out.println(100000000);
	v = new MyVisitor();
	System.out.println(50000000);
	nti = root.accept(v);
	System.out.println(100000000);
	System.out.println(root.Search(24));
	System.out.println(root.Search(12));
	System.out.println(root.Search(16));
	System.out.println(root.Search(50));
	System.out.println(root.Search(12));
	ntb = root.Delete(12);
	ntb = root.Print();
	System.out.println(root.Search(12));

	return 0 ;
    }

}


class Tree{
    Tree left ;
    Tree right;
    int key ;
    boolean has_left ;
    boolean has_right ;
    Tree my_null ;



    //Tree new_node ;
    //Tree current_node ;
    //Tree parent_node ;
    
   // boolean ntb ;
    //boolean cont ;
    //boolean found ;
    //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
   // int auxkey1 ;
   // int auxkey2 ;

    public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
    }

    public boolean SetRight(Tree rn){
	right = rn ;
	return true ;
    }

    public boolean SetLeft(Tree ln){
	left = ln ;
	return true ;
    }

    public Tree GetRight(){
	return right ;
    }

    public Tree GetLeft(){
	return left;
    }

    public int GetKey(){
	return key ;
    }

    public boolean SetKey(int v_key){
	key = v_key ;
	return true ;
    }

    public boolean GetHas_Right(){
	return has_right ;
    }

    public boolean GetHas_Left(){
	return has_left ;
    }

    public boolean SetHas_Left(boolean val){
	 has_left = val ;
	 return true ;
    }

    public boolean SetHas_Right(boolean val){
	 has_right = val ;
	 return true ;
    }

    public boolean Compare(int num1 , int num2){
	boolean ntb ;
	int nti ;

	ntb = false ;
	nti = num2 + 1 ;
	if (num1 < num2) ntb = false ;
	else if (!(num1 < nti)) ntb = false ;
	else ntb = true ;
	return ntb ;
    }

    public boolean Insert(int v_key){
	Tree new_node ;
	boolean ntb ;
	Tree current_node ;
	boolean cont ;
	int key_aux ;

	new_node = new Tree();
	ntb = new_node.Init(v_key) ;
	current_node = this ;
	cont = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux){
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Left(true);
		    ntb = current_node.SetLeft(new_node);
		}
	    }
	    else{
		if (current_node.GetHas_Right())
		    current_node = current_node.GetRight() ;
		else {
		    cont = false ;
		    ntb = current_node.SetHas_Right(true);
		    ntb = current_node.SetRight(new_node);
		}
	    }
	}
	return true ;
    }

    public boolean Delete(int v_key){
	Tree current_node ;
	Tree parent_node ;
	boolean cont ;
	boolean found ;
	boolean ntb ;
	boolean is_root ;
	int key_aux ;

	current_node = this ;
	parent_node = this ;
	cont = true ;
	found = false ;
	is_root = true ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left()){
		    parent_node = current_node ;
		    current_node = current_node.GetLeft() ;
		}
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right()){
			parent_node = current_node ;
			current_node = current_node.GetRight() ;
		    }
		    else cont = false ;
		else { 
		    if (is_root) 
			if (!current_node.GetHas_Right() && 
			    !current_node.GetHas_Left() )
			    ntb = true ;
			else 
			    ntb = this.Remove(parent_node,current_node); 
		    else ntb = this.Remove(parent_node,current_node);
		    found = true ;
		    cont = false ;
		}
	    is_root = false ;
	}
	return found ;
    }

    public boolean Remove(Tree p_node, Tree c_node){
	boolean ntb ;
	int auxkey1 ;
	int auxkey2 ;
	
	if (c_node.GetHas_Left()) 
	    ntb = this.RemoveLeft(p_node,c_node) ;
	else 
	    if (c_node.GetHas_Right())
		ntb = this.RemoveRight(p_node,c_node) ;
	    else {
		auxkey1 = c_node.GetKey();
		auxkey2 = (p_node.GetLeft()).GetKey() ;
		if (this.Compare(auxkey1,auxkey2)) {
		    ntb = p_node.SetLeft(my_null);
		    ntb = p_node.SetHas_Left(false);
		}
		else {
		    ntb = p_node.SetRight(my_null);
		    ntb = p_node.SetHas_Right(false);
		}
	    }
	return true ;
    }

    public boolean RemoveRight(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Right()){
	    ntb = c_node.SetKey((c_node.GetRight()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetRight() ;
	}
	ntb = p_node.SetRight(my_null);
	ntb = p_node.SetHas_Right(false);
	return true ;
    }

    public boolean RemoveLeft(Tree p_node, Tree c_node){
	boolean ntb ;
	while (c_node.GetHas_Left()){
	    ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
	    p_node = c_node ;
	    c_node = c_node.GetLeft() ;
	}
	ntb = p_node.SetLeft(my_null);
	ntb = p_node.SetHas_Left(false);
	return true ;
    }


    public int Search(int v_key){
	Tree current_node ;
	int ifound ;
	boolean cont ;
	int key_aux ;

	current_node = this ;
	cont = true ;
	ifound = 0 ;
	while (cont){
	    key_aux = current_node.GetKey();
	    if (v_key < key_aux)
		if (current_node.GetHas_Left())
		    current_node = current_node.GetLeft() ;
		else cont = false ;
	    else 
		if (key_aux < v_key)
		    if (current_node.GetHas_Right())
			current_node = current_node.GetRight() ;
		    else cont = false ;
		else { 
		    ifound = 1 ;
		    cont = false ;
		}
	}
	return ifound ;
    }

    public boolean Print(){
	boolean ntb ;
	Tree current_node ;

	current_node = this ;
	ntb = this.RecPrint(current_node);
	return true ;
    }

    public boolean RecPrint(Tree node){
	boolean ntb ;

	if (node.GetHas_Left()){
	    ntb = this.RecPrint(node.GetLeft());
	} else ntb = true ;
	System.out.println(node.GetKey());
	if (node.GetHas_Right()){
	    ntb = this.RecPrint(node.GetRight());
	} else ntb = true ;
	return true ;
    }
    
    public int accept(Visitor v){
	int nti ;

	System.out.println(333);
	nti = v.visit(this) ;
	return 0 ;
    }

}

  

class Visitor {
    Tree l ;
    Tree r ;

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti = l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}


class MyVisitor extends Visitor {

    public int visit(Tree n){
	int nti ;

	if (n.GetHas_Right()){
	    r = n.GetRight() ;
	    nti = r.accept(this) ; }
	else nti = 0 ;

	System.out.println(n.GetKey());

	if (n.GetHas_Left()) {
	    l = n.GetLeft(); 
	    nti =l.accept(this) ; }
	else nti = 0 ;

	return 0;
    }

}
